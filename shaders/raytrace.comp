
#version 430 core

// ============= SPECTRAL CONSTANTS =============
const float MIN_WAVELENGTH = 380.0;
const float MAX_WAVELENGTH = 780.0;

const float VISIBLE_WAVELENGTHS[11] = float[11](
    380.0, 420.0, 460.0, 500.0, 540.0, 580.0, 
    620.0, 660.0, 700.0, 740.0, 780.0
);

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f) uniform image2D outputImage;

uniform vec2 uResolution;
uniform uint uNumVertices;
uniform uint uNumTriangles;
uniform uint uFrameIndex;
uniform int  uMode;        // 0=full brilliance, 1=diffuse debug, 2=bounce heatmap, 3=fire
uniform vec2 uCenterXZ;
uniform float uRadius;

layout(std430, binding = 0) readonly buffer Vertices {
    vec4 posNormal[];
};

layout(std430, binding = 1) readonly buffer Triangles {
    uvec4 triangles[];
};

struct Hit {
    float t;
    int   triId;
    vec3  normal;
};

vec3 getPosition(uint vertexIndex) {
    uint base = vertexIndex * 2u;
    return posNormal[base].xyz;
}

vec3 getNormal(uint vertexIndex) {
    uint base = vertexIndex * 2u + 1u;
    return normalize(posNormal[base].xyz);
}

bool rayTriangleIntersect(vec3 orig, vec3 dir, uint triIdx, out Hit hit) {
    uvec4 tri = triangles[triIdx];
    vec3 v0 = getPosition(tri.x);
    vec3 v1 = getPosition(tri.y);
    vec3 v2 = getPosition(tri.z);

    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p  = cross(dir, e2);
    float det = dot(e1, p);
    if (abs(det) < 1e-6) return false;

    float invDet = 1.0 / det;
    vec3 tvec = orig - v0;
    float u = dot(tvec, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(tvec, e1);
    float v = dot(q, dir) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;

    float t = dot(e2, q) * invDet;
    if (t <= 1e-4) return false;

    float w = 1.0 - u - v;
    vec3 n0 = getNormal(tri.x);
    vec3 n1 = getNormal(tri.y);
    vec3 n2 = getNormal(tri.z);
    vec3 n  = normalize(w * n0 + u * n1 + v * n2);

    hit.t      = t;
    hit.triId  = int(triIdx);
    hit.normal = n;
    return true;
}

// ================= RNG =================
uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

float rand01(inout uint state) {
    state = hash_u32(state);
    return float(state) / 4294967296.0;
}

// ============ Dielectric helpers ============
float fresnelSchlick(float cosTheta, float etaI, float etaT) {
    float r0 = (etaI - etaT) / (etaI + etaT);
    r0 = r0 * r0;
    float m = 1.0 - cosTheta;
    return r0 + (1.0 - r0) * m * m * m * m * m;
}

bool refractRay(vec3 I, vec3 N, float etaI, float etaT, out vec3 T) {
    float eta  = etaI / etaT;
    float cosI = clamp(-dot(N, I), -1.0, 1.0);
    float sin2T = eta * eta * (1.0 - cosI * cosI);
    if (sin2T > 1.0) return false;
    float cosT = sqrt(1.0 - sin2T);
    T = normalize(eta * I + (eta * cosI - cosT) * N);
    return true;
}

// Sellmeier equation for diamond (accurate across spectrum)
float iorDiamondForWavelength(float wavelength_nm) {
    float lambda_um = wavelength_nm / 1000.0;
    float l2 = lambda_um * lambda_um;
    
    // Sellmeier coefficients (CRC Handbook of Chemistry & Physics)
    float B1 = 0.3306;
    float C1 = 0.1750 * 0.1750;
    float B2 = 4.3356;
    float C2 = 0.1060 * 0.1060;
    
    float n2 = 1.0 + B1*l2/(l2-C1) + B2*l2/(l2-C2);
    return sqrt(max(n2, 1.0));
}

// Legacy function for backward compatibility (single-wavelength)
float iorDiamondForChannel(int c) {
    float waves[3] = float[](650.0, 550.0, 450.0); // R, G, B
    return iorDiamondForWavelength(waves[c]);
}


// Updated for sunlight + sky dome
// FIXED: Much brighter dome for brilliance
// RESTORED: Original dome brightness + subtle sun
vec3 sampleEnvironment(vec3 dir) {
    // ORIGINAL dome logic (worked well)
    float up = max(dir.y, 0.0); 
    float dome = smoothstep(0.7, 1.0, up);
    vec3 skyColor = vec3(0.02) + vec3(0.8) * dome;  // Slightly brighter
    
    // Add controlled sun disk
    vec3 sunDir = normalize(vec3(0.7, 1.2, 0.7));
    float sunDot = max(dot(dir, sunDir), 0.0);
    if (sunDot > 0.97) {
        skyColor += vec3(3.0);  // Controlled boost
    }
    
    return skyColor;
}




// Fire: 3 colored point lights (Mode 3)
vec3 sampleFireEnvironment(vec3 dir) {
    vec3 L0 = normalize(vec3( 1.0,  2.0,  1.0));
    vec3 L1 = normalize(vec3(-1.0,  2.0,  1.0));
    vec3 L2 = normalize(vec3( 0.0,  2.0, -1.5));

    vec3 C0 = vec3(1.0, 0.1, 0.1);  // Red-heavy
    vec3 C1 = vec3(0.1, 1.0, 0.1);  // Green-heavy
    vec3 C2 = vec3(0.1, 0.1, 1.0);  // Blue-heavy

    float w0 = pow(max(dot(dir, L0), 0.0), 16.0);
    float w1 = pow(max(dot(dir, L1), 0.0), 16.0);
    float w2 = pow(max(dot(dir, L2), 0.0), 16.0);

    vec3 col = C0 * w0 + C1 * w1 + C2 * w2;
    return col + vec3(0.001);
}

// Fire dispersion IOR
//float iorDiamondForWavelength(float lambda_nm) {
    //float lambda_um = lambda_nm * 1e-3;
    //float l2 = lambda_um * lambda_um;
    //float B1 = 0.3306 * l2 / (l2 - 0.1750 * 0.1750);
    //float B2 = 4.3356 * l2 / (l2 - 0.1060 * 0.1060);
    //return sqrt(1.0 + B1 + B2);
//}

// CIE 1931 standard observer wavelength to RGB
vec3 wavelengthToRGB(float wavelength_nm) {
    float wave = wavelength_nm;
    float r = 0.0, g = 0.0, b = 0.0;
    
    if (wave < 420.0) {
        r = 0.3 + 0.7 * (1.0 - (420.0 - wave) / 40.0);
        b = 1.0;
    }
    else if (wave < 490.0) {
        b = 1.0;
        g = (wave - 420.0) / 70.0;
    }
    else if (wave < 575.0) {
        b = 1.0 - (wave - 490.0) / 85.0;
        g = 1.0;
    }
    else if (wave < 620.0) {
        r = (wave - 575.0) / 45.0;
        g = 1.0;
    }
    else if (wave < 750.0) {
        r = 1.0;
        g = 1.0 - (wave - 620.0) / 130.0;
    }
    else {
        r = max(1.0 - (wave - 750.0) / 30.0, 0.3);
    }
    
    // Intensity correction (less bright at edges)
    float intensity = 1.0;
    if (wave < 420.0 || wave > 700.0) {
        intensity = 0.3;
    }
    
    return vec3(r, g, b) * intensity;
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(uResolution.x) || pixel.y >= int(uResolution.y)) return;

    vec2 pixCenter = (vec2(pixel) + 0.5) / uResolution;
    vec2 ndc = pixCenter * 2.0 - 1.0;
    float radiusXZ = uRadius;
    float camY = radiusXZ * 3.0;
    float baseX = uCenterXZ.x + ndc.x * radiusXZ;
    float baseZ = uCenterXZ.y + ndc.y * radiusXZ;

    // Mode 1: diffuse debug
    if (uMode == 1) {
        vec3 rayOrigin = vec3(baseX, camY, baseZ);
        vec3 rayDir = vec3(0.0, -1.0, 0.0);
        Hit closest; closest.t = 1e30; bool hit = false;
        for (uint i = 0u; i < uNumTriangles; ++i) {
            Hit h;
            if (rayTriangleIntersect(rayOrigin, rayDir, i, h) && h.t < closest.t) {
                closest = h; hit = true;
            }
        }
        vec3 col = vec3(0.0);
        if (hit) {
            vec3 N = normalize(closest.normal);
            if (N.y < 0.0) N = -N;
            vec3 lightDir = normalize(vec3(0.0, -1.0, 0.0));
            float ndotl = max(dot(N, -lightDir), 0.0);
            float diffuse = pow(ndotl, 0.6);
            float r = length(vec2(baseX - uCenterXZ.x, baseZ - uCenterXZ.y));
            float vignette = smoothstep(radiusXZ, 0.0, r);
            float b = diffuse * vignette;
            col = vec3(0.15) + vec3(0.85) * b;
        }
        imageStore(outputImage, pixel, vec4(col, 1.0));
        return;
    }

    uint seed = uint(pixel.x) * 1973u ^ uint(pixel.y) * 9277u ^ uFrameIndex * 26699u;

    // Mode 2: bounce heatmap
    if (uMode == 2) {
        const int MAX_DEPTH = 10;
        int bounceCount = 0;
        vec3 rayOrigin = vec3(baseX, camY, baseZ);
        vec3 rayDir = vec3(0.0, -1.0, 0.0);
        bool insideDiamond = false;
        for (int depth = 0; depth < MAX_DEPTH; ++depth) {
            Hit closest; closest.t = 1e30; bool hit = false;
            for (uint i = 0u; i < uNumTriangles; ++i) {
                Hit h;
                if (rayTriangleIntersect(rayOrigin, rayDir, i, h) && h.t < closest.t) {
                    closest = h; hit = true;
                }
            }
            if (!hit) break;
            ++bounceCount;
            vec3 N = normalize(closest.normal);
            if (dot(N, rayDir) > 0.0) N = -N;
            float etaAir = 1.0, etaDiamond = 2.42;
            float etaI = insideDiamond ? etaDiamond : etaAir;
            float etaT = insideDiamond ? etaAir : etaDiamond;
            vec3 refrDir; bool canRefract = refractRay(rayDir, N, etaI, etaT, refrDir);
            vec3 reflDir = reflect(rayDir, N);
            if (canRefract) {
                insideDiamond = !insideDiamond;
                rayDir = normalize(refrDir);
            } else {
                rayDir = normalize(reflDir);
            }
            rayOrigin = rayOrigin + rayDir * (closest.t + 1e-3);
        }
        float t = clamp(float(bounceCount) / 8.0, 0.0, 1.0);
        vec3 heat = vec3(t, t*t, t*t*t);
        imageStore(outputImage, pixel, vec4(heat, 1.0));
        return;
    }

    // Mode 3: FIRE with DIRECTIONAL SUNLIGHT (spectral dispersion)
    if (uMode == 3) {
    // FIRE-SPECIFIC: Higher quality for dispersion paths
    const int SAMPLES_PER_FRAME = 12;      // More samples
    const int MAX_DEPTH = 16;              // MORE bounces for fire paths
    const int NUM_WAVELENGTHS = 7;         // More spectral samples
    vec3 sampleSum = vec3(0.0);
    
    // TRUE POINT SOURCE (not directional sun)
    vec3 lightDir = normalize(vec3(1.2, 2.0, 0.8));  // Off-axis point light
    vec3 lightIntensity = vec3(20.0);  // Very bright point source
    
    for (int s = 0; s < SAMPLES_PER_FRAME; ++s) {
        vec2 jitter = vec2(rand01(seed), rand01(seed));
        vec2 uv = (vec2(pixel) + jitter) / uResolution;
        vec2 ndcJ = uv * 2.0 - 1.0;
        float xj = uCenterXZ.x + ndcJ.x * radiusXZ;
        float zj = uCenterXZ.y + ndcJ.y * radiusXZ;
        
        vec3 rayOrigin = vec3(xj, camY, zj);
        vec3 rayDir = vec3(0.0, -1.0, 0.0);
        bool insideDiamond = false;
        
        // FIRE: Sample ONE wavelength per path (correct spectral path tracing)
        float wavelength = mix(400.0, 700.0, rand01(seed));  // Full visible
        float etaDiamond = iorDiamondForWavelength(wavelength);
        float etaAir = 1.0;
        
        float throughput = 1.0;
        vec3 radiance = vec3(0.0);
        
        for (int depth = 0; depth < MAX_DEPTH; ++depth) {
            Hit closest; closest.t = 1e30; bool hit = false;
            
            // Triangle intersection (same as before)
            for (uint i = 0u; i < uNumTriangles; ++i) {
                Hit h;
                if (rayTriangleIntersect(rayOrigin, rayDir, i, h) && h.t < closest.t) {
                    closest = h; hit = true;
                }
            }
            
            if (!hit) {
                // FIRE: Check if ray sees the point light source
                float lightDot = max(dot(-rayDir, lightDir), 0.0);
                if (lightDot > 0.999) {  // Very tight cone (1Â° point source)
                    radiance += throughput * lightIntensity;
                }
                // Dark background for fire contrast
                break;
            }
            
            vec3 N = normalize(closest.normal);
            if (dot(N, rayDir) > 0.0) N = -N;
            vec3 hitPoint = rayOrigin + rayDir * closest.t;
            
            // Reduced absorption for fire paths
            if (insideDiamond) {
                float sig = 0.008;  // Low absorption
                throughput *= exp(-sig * closest.t);
            }
            
            // CRITICAL: Wavelength-dependent Fresnel/refraction
            float etaI = insideDiamond ? etaDiamond : etaAir;
            float etaT = insideDiamond ? etaAir : etaDiamond;
            float cosThetaI = clamp(-dot(N, rayDir), 0.0, 1.0);
            float F = fresnelSchlick(cosThetaI, etaI, etaT);
            
            vec3 reflDir = reflect(rayDir, N);
            vec3 refrDir;
            bool canRefract = refractRay(rayDir, N, etaI, etaT, refrDir);
            
            float xi = rand01(seed);
            bool doReflect = (!canRefract) || (xi < F);
            
            if (doReflect) {
                rayDir = normalize(reflDir);
            } else {
                insideDiamond = !insideDiamond;
                rayDir = normalize(refrDir);
            }
            
            rayOrigin = hitPoint + rayDir * 1e-3;
            
            // FIRE: Less aggressive termination (need long paths)
            if (depth >= 8) {
                float p = clamp(throughput, 0.02, 0.98);
                if (rand01(seed) > p) break;
                throughput /= p;
            }
        }
        
        // Convert single wavelength path to color
        vec3 spectralColor = wavelengthToRGB(wavelength);
        sampleSum += radiance * spectralColor;
    }
    
    vec3 frameColor = sampleSum / float(SAMPLES_PER_FRAME);
    vec4 prev = imageLoad(outputImage, pixel);
    vec3 newAccum = prev.rgb + frameColor;
    imageStore(outputImage, pixel, vec4(newAccum, 1.0));
    return;
}




    // Mode 0: SPECTRAL BRILLIANCE (with proper dispersion)
    const int SAMPLES_PER_FRAME = 8;  // More samples for smooth spectral rendering
    const int MAX_DEPTH = 10;
    vec3 sampleSum = vec3(0.0);

    for (int s = 0; s < SAMPLES_PER_FRAME; ++s) {
        // Sample a random wavelength from visible spectrum
        float wavelength = mix(MIN_WAVELENGTH, MAX_WAVELENGTH, rand01(seed));
        float etaDiamond = iorDiamondForWavelength(wavelength);
        //float etaDiamond = 2.42;
        float etaAir = 1.0;
        
        vec2 jitter = vec2(rand01(seed), rand01(seed));
        vec2 uv = (vec2(pixel) + jitter) / uResolution;
        vec2 ndcJ = uv * 2.0 - 1.0;
        float xj = uCenterXZ.x + ndcJ.x * radiusXZ;
        float zj = uCenterXZ.y + ndcJ.y * radiusXZ;
        
        vec3 rayOrigin = vec3(xj, camY, zj);
        vec3 rayDir = normalize(vec3(0.0, -1.0, 0.0));  // Sunlight direction
        float throughput = 1.0;
        vec3 radiance = vec3(0.0);
        bool insideDiamond = false;
        
        for (int depth = 0; depth < MAX_DEPTH; ++depth) {
            Hit closest;
            closest.t = 1e30;
            bool hit = false;
            
            for (uint i = 0u; i < uNumTriangles; ++i) {
                Hit h;
                if (rayTriangleIntersect(rayOrigin, rayDir, i, h) && h.t < closest.t) {
                    closest = h;
                    hit = true;
                }
            }
            
            if (!hit) {
                // Ray escaped - environment (sunlight dome)
                vec3 env = sampleEnvironment(rayDir);
                radiance += throughput * env;
                break;
            }
            
            vec3 N = normalize(closest.normal);
            if (dot(N, rayDir) > 0.0) N = -N;
            vec3 hitPoint = rayOrigin + rayDir * closest.t;
            
            // Absorption in diamond
            if (insideDiamond) {
                float absorption = 0.018;  // Was 0.03 (6x less!)
                throughput *= exp(-absorption * closest.t);
            }
            
            // Fresnel & refraction with wavelength-dependent IOR
            float etaI = insideDiamond ? etaDiamond : etaAir;
            float etaT = insideDiamond ? etaAir : etaDiamond;
            float cosThetaI = clamp(-dot(N, rayDir), 0.0, 1.0);
            float F = fresnelSchlick(cosThetaI, etaI, etaT);
            
            vec3 reflDir = reflect(rayDir, N);
            vec3 refrDir;
            bool canRefract = refractRay(rayDir, N, etaI, etaT, refrDir);
            
            // Probabilistic reflection/refraction
            float xi = rand01(seed);
            bool doReflect = (!canRefract) || (xi < F);
            
            if (doReflect) {
                rayDir = normalize(reflDir);
            } else {
                insideDiamond = !insideDiamond;
                rayDir = normalize(refrDir);
            }
            
            rayOrigin = hitPoint + rayDir * 1e-3;
            
            // Russian roulette termination
            if (depth >= 4) {
                float p = clamp(throughput, 0.08, 0.92);
                if (rand01(seed) > p) break;
                throughput /= p;
            }
        }
        
        // Convert wavelength to RGB color
        vec3 color = wavelengthToRGB(wavelength);
        color = mix(vec3(1.0), color, 0.3);  // 70% white + 30% spectral
        sampleSum += radiance * color;
    }

    vec3 frameColor = sampleSum / float(SAMPLES_PER_FRAME);
    vec4 prev = imageLoad(outputImage, pixel);
    vec3 newAccum = prev.rgb + frameColor;
    imageStore(outputImage, pixel, vec4(newAccum, 1.0));

}
